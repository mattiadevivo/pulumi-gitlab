# WARNING: This file is autogenerated - changes will be overwritten if not made via https://github.com/pulumi/ci-mgmt

PACK := gitlab
ORG := pulumi
PROJECT := github.com/$(ORG)/pulumi-$(PACK)
PROVIDER_PATH := provider/v4
VERSION_PATH := $(PROVIDER_PATH)/pkg/version.Version
TFGEN := pulumi-tfgen-$(PACK)
PROVIDER := pulumi-resource-$(PACK)
VERSION := $(shell pulumictl get version)
JAVA_GEN := pulumi-java-gen
JAVA_GEN_VERSION := v0.5.4
TESTPARALLELISM := 10
WORKING_DIR := $(shell pwd)

development: install_plugins provider build_sdks install_sdks

build: install_plugins provider build_sdks install_sdks

build_sdks: build_nodejs build_python build_go build_dotnet build_java

install_go_sdk:

install_java_sdk:

install_python_sdk:

install_sdks: install_dotnet_sdk install_python_sdk install_nodejs_sdk install_java_sdk

only_build: build

build_dotnet: DOTNET_VERSION := $(shell pulumictl get version --language dotnet)
build_dotnet: upstream
	pulumictl get version --language dotnet
	$(WORKING_DIR)/bin/$(TFGEN) dotnet --out sdk/dotnet/
	cd sdk/dotnet/ && \
		echo "module fake_dotnet_module // Exclude this directory from Go tools\n\ngo 1.17" > go.mod && \
		echo "$(DOTNET_VERSION)" >version.txt && \
		dotnet build /p:Version=$(DOTNET_VERSION)

build_go: upstream
	$(WORKING_DIR)/bin/$(TFGEN) go --out sdk/go/
	cd sdk && go list `grep -e "^module" go.mod | cut -d ' ' -f 2`/go/... | xargs go build

build_java: PACKAGE_VERSION := $(shell pulumictl get version --language generic)
build_java: bin/pulumi-java-gen upstream
	$(WORKING_DIR)/bin/$(JAVA_GEN) generate --schema provider/cmd/$(PROVIDER)/schema.json --out sdk/java  --build gradle-nexus
	cd sdk/java/ && \
		echo "module fake_java_module // Exclude this directory from Go tools\n\ngo 1.17" > go.mod && \
		gradle --console=plain build

build_nodejs: VERSION := $(shell pulumictl get version --language javascript)
build_nodejs: upstream
	$(WORKING_DIR)/bin/$(TFGEN) nodejs --out sdk/nodejs/
	cd sdk/nodejs/ && \
		echo "module fake_nodejs_module // Exclude this directory from Go tools\n\ngo 1.17" > go.mod && \
		yarn install && \
		yarn run tsc && \
		cp ../../README.md ../../LICENSE* package.json yarn.lock ./bin/ && \
		sed -i.bak -e "s/\$${VERSION}/$(VERSION)/g" ./bin/package.json

build_python: PYPI_VERSION := $(shell pulumictl get version --language python)
build_python: upstream
	$(WORKING_DIR)/bin/$(TFGEN) python --out sdk/python/
	cd sdk/python/ && \
		echo "module fake_python_module // Exclude this directory from Go tools\n\ngo 1.17" > go.mod && \
		cp ../../README.md . && \
		python3 setup.py clean --all 2>/dev/null && \
		rm -rf ./bin/ ../python.bin/ && cp -R . ../python.bin && mv ../python.bin ./bin && \
		sed -i.bak -e 's/^VERSION = .*/VERSION = "$(PYPI_VERSION)"/g' -e 's/^PLUGIN_VERSION = .*/PLUGIN_VERSION = "$(VERSION)"/g' ./bin/setup.py && \
		rm ./bin/setup.py.bak && rm ./bin/go.mod && \
		cd ./bin && python3 setup.py build sdist

clean:
	rm -rf sdk/{dotnet,nodejs,go,python}

cleanup:
	rm -r $(WORKING_DIR)/bin
	rm -f provider/cmd/$(PROVIDER)/schema.go

help:
	@grep '^[^.#]\+:\s\+.*#' Makefile | \
	sed "s/\(.\+\):\s*\(.*\) #\s*\(.*\)/`printf "\033[93m"`\1`printf "\033[0m"`	\3 [\2]/" | \
	expand -t20

install_dotnet_sdk:
	mkdir -p $(WORKING_DIR)/nuget
	find . -name '*.nupkg' -print -exec cp -p {} $(WORKING_DIR)/nuget \;

install_nodejs_sdk:
	yarn link --cwd $(WORKING_DIR)/sdk/nodejs/bin

install_plugins:
	[ -x "$(shell command -v pulumi 2>/dev/null)" ] || curl -fsSL https://get.pulumi.com | sh

lint_provider: provider
	cd provider && golangci-lint run -c ../.golangci.yml

provider: tfgen install_plugins
	(cd provider && go build $(PULUMI_PROVIDER_BUILD_PARALLELISM) -o $(WORKING_DIR)/bin/$(PROVIDER) -ldflags "-X $(PROJECT)/$(VERSION_PATH)=$(VERSION)" $(PROJECT)/$(PROVIDER_PATH)/cmd/$(PROVIDER))

test:
	cd examples && go test -v -tags=all -parallel $(TESTPARALLELISM) -timeout 2h

tfgen: install_plugins upstream
	(cd provider && go build $(PULUMI_PROVIDER_BUILD_PARALLELISM) -o $(WORKING_DIR)/bin/$(TFGEN) -ldflags "-X $(PROJECT)/$(VERSION_PATH)=$(VERSION)" $(PROJECT)/$(PROVIDER_PATH)/cmd/$(TFGEN))
	$(WORKING_DIR)/bin/$(TFGEN) schema --out provider/cmd/$(PROVIDER)
	(cd provider && VERSION=$(VERSION) go generate cmd/$(PROVIDER)/main.go)

define REBASE_IN_PROGRESS
	@echo 'A rebase is already in progress. To finish the current rebase,'
	@echo 'complete the `git rebase` in `./upstream` and then run:'
	@echo
	@echo '    make upstream.toPatches'
	@echo
	@echo 'If you want to abandon the rebase currently in progress and'
	@echo 'execute this target anyway, run:'
	@echo
	@echo '    rm rebase-in-progress && make $@'
	@echo
	@exit 1
endef

upstream.rebase:
ifeq ("$(wildcard upstream)","")
	@echo "No upstream directory detected, so it doesn't make sense to run upstream based commands"
	exit 1
else ifneq ("$(wildcard rebase-in-progress)","") # Make sure we don't overwrite a rebase in progress
	${REBASE_IN_PROGRESS}
else
	git submodule update --force --init
	cd upstream && git fetch
ifeq ("${TO}","")
	# TO not specified, assuming TO is the upstream SHA currently commited
else
	cd upstream && git checkout ${TO}
endif
	cd upstream && git checkout -B local
	# We use a local tag branch here because our upstream is almost always a tag, and
	# we can't rebase into a tag.
	cd upstream && git checkout -B pulumi-patch ${FROM}
	cd upstream && git branch --set-upstream-to=local pulumi-patch
	@cd upstream && for patch in $(sort $(wildcard patches/*.patch)); do \
		echo "Applying $$patch"; \
		if ! git apply --3way ../$$patch; then \
			echo '\nFailed to apply patch. Please run "make upstream.rebase FROM=$$TAG where $$TAG is a known safe version\n'; \
			exit 1; \
		fi; \
		patch=$${patch#patches/*-}; \
		git commit -am "$${patch%.patch}"; \
	done
	@touch rebase-in-progress
	@cd upstream && if git rebase local; then \
		echo ; \
		echo 'The full patch set has been cleanly applied to the `./upstream` repository.'; \
		echo 'To "edit" the patch set, commit changes directly to `./upstream`. When'; \
		echo 'you are done making changes, run '; \
		echo ; \
		echo '    make upstream.toPatches'; \
		echo ; \
		echo 'to finish the rebase and commit those changes into the patch set.'; \
	else \
		echo ; \
		echo 'The patch set did not apply cleanly. You need to manually resolve'; \
		echo 'rebase conflicts directly in `./upstream`. When you have completed'; \
		echo 'the rebase, run' ;\
		echo ; \
		echo '    make upstream.toPatches'; \
		echo ; \
		echo 'This will finalize the changes you made back into the patch set.'; \
	fi
endif

upstream.toPatches:
ifeq ("$(wildcard rebase-in-progress)","")
	@echo "Didn't detect an upstream rebase in progress."
	@echo "To start an upstream rebase, run"
	@echo
	@echo '    make upstream.rebase [FROM=vX.Y.Z] [TO=vA.B.C]'
	@echo
	@echo "If you are absolutly sure you are already in a rebase, run"
	@echo
	@echo "    touch rebase-in-progress && make $@"
	@echo
	@exit 1
else
	@rm $(sort $(wildcard patches/*.patch))
	cd upstream && git format-patch local -o ../patches
	@rm rebase-in-progress
endif

upstream:
ifeq ("$(wildcard upstream)","")
	@# "upstream doesn't exist, so skip"
else ifeq ("$(wildcard patches/*.patch)","")
	@# "upstream exists, but patches don't exist. This is probably an error."
	@echo "No patches found within the patch operation"
	@echo "patches were expected because upstream exists"
	@exit 1
else ifneq ("$(wildcard rebase-in-progress)","")
	${REBASE_IN_PROGRESS}
else
	@# Checkout the submodule at the pinned commit.
	@# `--force`: If the submodule is at a different commit, move it to the pinned commit.
	@# `--init`: If the submodule is not initialized, initialize it.
	@git submodule update --force --init
	@# Iterating over the patches folder in sorted order,
	@# apply the patch using a 3-way merge strategy. This mirrors the default behavior of `git merge`
	@cd upstream && for patch in $(sort $(wildcard patches/*.patch)); do \
		git apply --3way ../$$patch; \
		if ! [ $$? = 0 ]; then \
		echo ; \
		echo '`make $@` failed to apply a patch. This is because there is a conflict between'; \
		echo 'the checkout version of upstream and the patch set. To resolve this conflict'; \
		echo 'run'; \
		echo ; \
		echo '    make upstream.rebase FROM=$$LAST_KNOWN_GOOD_COMMIT'; \
		echo ; \
		echo 'This will walk you through resolving the conflict and producing a new patch set'; \
		echo 'that applies cleanly to `$$DESIRED_COMMTI`.'; \
		echo ; \
		exit 1; fi \
	done
endif

bin/pulumi-java-gen:
	$(shell pulumictl download-binary -n pulumi-language-java -v $(JAVA_GEN_VERSION) -r pulumi/pulumi-java)

.PHONY: development build build_sdks install_go_sdk install_java_sdk install_python_sdk install_sdks only_build build_dotnet build_go build_java build_nodejs build_python clean cleanup help install_dotnet_sdk install_nodejs_sdk install_plugins lint_provider provider test tfgen upstream upstream.rebase upstream.toPatches
